# TypeScript

## Профессиональная обработка ошибок

[Ссылка](https://habr.com/ru/companies/piter/articles/935278/)

Небольшой перевод небольшой статьи про обработку ошибок в JS. Статья достаточно простая, но в ней рассказывается о важном концепте - обработка ошибок.

Часто никто не задумывается о том, как вообще работать с ошибками. Дай бог если где-то в коде вообще будет написан catch и что-то обработано. "Unknown Error", "что-то пошло не так", "oops", "попробуйте еще раз" прочно вошли в нашу жизнь и никто уже не удивляется, когда видит в UI нечто непонятное.

В статье рассказывается, что хорошо бы поделить ошибки на "ожидаемые" - это те, про которые нам известно и примерно понятно, как их следует обрабатывать, и "неожиданные" - это те, про которые мы не в курсе, или в курсе их существования, но не ожидаем таких ошибок (пример кейса "знаем, но не ожидаем" - не ожидаем, что будет ошибка резолва DNS из нашей nodejs до нашего же API на java)

Ошибки, по-хорошему, нужно обрабатывать. Но механизм throw => try-catch не очень удобен для этого - флоу обработки ошибок не очевиден. Вместо этого автор предлагает использовать Result-монаду из библиотеки true-myth (лично я своих проектах использую библиотеку ts-results).

Если мы начинаем использовать Result-монаду как результат функции, то сама монада заставляет нас явно обрабатывать ошибки. Как следствие:

- Есть явный, очевидный флоу обработки ошибок от любой функции.
- TS может требовать корректной обработки ошибок (если не лениться типизировать то, что лежит в result-монаде).

Как это выглядит?

Без result-монады:

```ts
async function createUser(newUser: NewUser): User {
return { ... };
}

try {
const user = await registerUser();
return { status: 200, user };
} catch (e) {
if (e instanceof UserNameTaken) {
return { status: 400, message: 'User name taken' };
}
throw e;
}
```

с Result-монадой:

```ts
type UserResult =
| { result: 'success', user: User }
| { result: 'error', error: Error };

async function createUser(newUser: NewUser): UserResult {
return { ... };
}

// Вызывающий код:
const userResult = createUser(newUser);

if (userResult.result === 'error') {
if (userResult.error.code === 'User name taken') {
return { status: 400, message: 'User name taken' };
}

// иначе возвращаем ошибку выше по флоу
return userResult;

}

return { status: 200, user };
```

В примере кода могут быть не очевидно, зачем вообще использовать result - кода стало больше, а не меньше. Но:

- Теперь TS требует явно проверять результат и ошибки. Забыть написать обработку ошибок невозможно (ну или нужно явно подавить ошибки TS).
- Все ошибки можно типизировать. Ну или хотя бы ожидаемые ошибки.
- Result-монады хорошо композируются. Если result-монада - стандарт для возврата.результата функции, то передача результата между слоями (как в примере выше с неизвестной ошибкой) либо требует 0 усилий, либо требует небольшой переупаковки ошибки.

В более менее серьезных пет-проектах стараюсь использовать ts-results. Относительно недавно словил большой кайф от ts-results - я разрабатываю chrome-расширение и там периодически случаются ошибки связанные с сетевыми запросами, исключения от которых не обрабатываются. Повальный переход на ts-results в коде, связанном с сетевыми запросами и обработкой результатов позволил найти все места, где я не обрабатываю ошибки или обрабатываю на все, т.к. typescript явно мне подсказывал, что в коде не сходятся типы (не обработал ошибку, или обрабатываю как result, а функция возвращает не result - значит потенциально мог там не завернуть ошибку в result).
